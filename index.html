<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Sorry to my Diet Coke ü•§ ‚Äî Forgive Game</title>
  <style>
    /* Cute pastel theme */
    :root{
      --bg: #fffafc;
      --card: #fff;
      --accent: #ff7fb2;
      --accent-2: #ffd6e8;
      --muted: #7a7a8c;
      --shadow: 0 8px 30px rgba(33,30,50,0.08);
      --radius: 14px;
      --glass: rgba(255,255,255,0.7);
      --pixel-size: 8px; /* drawn by canvas, not CSS */
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #fffafc 0%, #fff6f9 60%);
      color:#2b2b3a;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
      min-height:100vh;
    }

    .wrap{
      width:100%;
      max-width:920px;
      background:var(--card);
      border-radius:20px;
      box-shadow:var(--shadow);
      padding:28px;
    }

    header{display:flex;align-items:center;gap:16px;}
    .logo {
      width:64px;height:64px;border-radius:12px;
      background:linear-gradient(135deg,var(--accent-2),#fff);
      display:flex;align-items:center;justify-content:center;
      box-shadow:0 6px 18px rgba(255,127,178,0.12);
      font-weight:700;color:#ffffff;font-size:24px;
    }
    h1{margin:0;font-size:1.3rem}
    p.lead{margin:8px 0 18px;color:var(--muted)}

    .center{
      display:flex;flex-direction:column;align-items:center;gap:16px;margin:18px 0 24px;
    }

    .forgive-btn{
      display:inline-flex;align-items:center;gap:10px;
      background:linear-gradient(180deg,var(--accent),#ff4b94);
      color:white;padding:12px 18px;border-radius:12px;border:none;
      font-weight:700;font-size:1rem;cursor:pointer;box-shadow:0 8px 20px rgba(255,127,178,0.18);
      transition:transform .14s ease, box-shadow .14s ease;
    }
    .forgive-btn:active{transform:translateY(2px)}
    .small-muted{font-size:0.86rem;color:var(--muted)}

    /* Pixel reveal area */
    .reveal-area{
      width:100%;display:flex;gap:20px;align-items:flex-start;flex-wrap:wrap;justify-content:center;
    }
    .pixel-canvas{
      background:linear-gradient(180deg,#fff,#fff6fb);
      border-radius:12px;padding:14px;display:flex;flex-direction:column;align-items:center;
      box-shadow:0 6px 20px rgba(170,120,160,0.05);
      border:1px solid #ffeef6;
    }
    canvas{display:block;border-radius:8px;background:transparent}

    .status{
      font-size:0.95rem;color:var(--muted);text-align:center;margin-top:8px;
    }

    /* Game area */
    .game{
      margin-top:18px;padding:14px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff6fb);
      border:1px solid #fff0f5;box-shadow:0 6px 20px rgba(100,70,120,0.03);
    }
    .game-grid{
      display:grid;grid-template-columns:repeat(4,1fr);gap:12px;max-width:520px;margin:12px auto;
    }
    .card{
      perspective:800px; width:100%; height:90px; cursor:pointer;
    }
    .card-inner{
      position:relative;width:100%;height:100%;transform-style:preserve-3d;transition:transform .45s cubic-bezier(.2,.9,.3,1);
      border-radius:10px;
    }
    .card.flipped .card-inner{transform:rotateY(180deg)}
    .face{
      position:absolute;inset:0;border-radius:10px;backface-visibility:hidden;display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(0,0,0,0.05);
    }
    .face.back{
      background:linear-gradient(180deg,#ffdff0,#fff4fb);
      color:var(--muted); font-weight:700;
      transform:rotateY(0);
    }
    .face.front{
      transform:rotateY(180deg); background:var(--glass);display:flex;align-items:center;justify-content:center;
    }
    .card img{width:64px;height:64px;image-rendering:pixelated}

    .message{
      text-align:center;margin-top:14px;font-weight:700;color:#ff4b94;
    }

    /* small responsive */
    @media (max-width:640px){
      .game-grid{grid-template-columns:repeat(2,1fr)}
      .card{height:84px}
    }

    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:0.88rem}
    /* sparkle when win */
    .win {
      animation: pop .6s ease;
    }
    @keyframes pop{
      0%{transform:scale(.98)}
      60%{transform:scale(1.06)}
      100%{transform:scale(1)}
    }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div class="logo">ü•§</div>
      <div>
        <h1>Sorry to my Diet Coke</h1>
        <p class="lead">I messed up ‚Äî but I brought bubbles and games. Click below to beg for forgiveness.</p>
      </div>
    </header>

    <div class="center">
      <button id="forgiveBtn" class="forgive-btn" aria-labelledby="forgiveLabel">
        ‚ù§Ô∏è I Forgive You
      </button>
      <div id="forgiveTip" class="small-muted">(Click the pink heart ‚Äî your Diet Coke is waiting.)</div>
    </div>

    <section class="reveal-area" aria-live="polite">
      <div id="pixelBlock" class="pixel-canvas" style="display:none;">
        <canvas id="pixelCanvas" width="120" height="200" aria-hidden="true"></canvas>
        <div class="status" id="revealStatus">Generating pixel Diet Coke‚Ä¶</div>
      </div>

      <div id="gameWrap" class="game" style="display:none;">
        <div class="small-muted" style="text-align:center">Match the cozy Diet Coke pairs ‚Äî find all 4 matches to restore our fizz!</div>
        <div class="game-grid" id="gameGrid" aria-label="Matching game"></div>
        <div class="message" id="gameMessage" role="status" aria-live="polite"></div>
      </div>
    </section>

    <footer>Made with silly apologies & tiny pixels üíñ</footer>
  </div>

  <script>
  /* ---------- Pixel art map (simple can) ----------
     We'll draw a small pixel map (w x h grid). 0 = transparent
     1 = red, 2 = white label, 3 = dark, 4 = light highlight
  --------------------------------------------------*/
  (function(){
    const grid = [
      // 10 x 16 (width x height)
      // each row is width=10
      [0,0,1,1,1,1,1,1,0,0],
      [0,1,1,1,1,1,1,1,1,0],
      [1,1,4,1,1,1,1,4,1,1],
      [1,1,1,1,2,2,1,1,1,1],
      [1,1,1,1,2,2,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [1,1,1,3,3,3,3,1,1,1],
      [0,1,1,1,1,1,1,1,1,0],
      [0,0,1,1,1,1,1,1,0,0]
    ];
    // color map
    const colors = {
      0: null,
      1: '#ff6fa1', // soft pink-red for pastel "Diet Coke"
      2: '#fff5f8', // label white
      3: '#e6cbd6', // darker body shading
      4: '#ffdff0'  // highlight
    };

    // Elements
    const canvas = document.getElementById('pixelCanvas');
    const ctx = canvas.getContext('2d');
    // We'll scale pixels to look chunky
    const pixelSize = 6; // final size (so canvas drawn size will be gridWidth*pixelSize)
    const w = grid[0].length;
    const h = grid.length;
    // Resize canvas to desired pixel scale (we used width/height attributes already but we'll draw scaled)
    canvas.width = w * pixelSize;
    canvas.height = h * pixelSize;
    ctx.imageSmoothingEnabled = false;

    // Helper to draw the full pixel can instantly (for card generation)
    function drawFull(scale = pixelSize){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const v = grid[y][x];
          if(!v) continue;
          ctx.fillStyle = colors[v];
          ctx.fillRect(x*scale, y*scale, scale, scale);
        }
      }
    }

    // Pixel-by-pixel reveal animation
    function revealPixelByPixel(onComplete){
      // clear first
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const positions = [];
      for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(grid[y][x]) positions.push({x,y, v:grid[y][x]});
      // shuffle order a bit for fun
      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }
      const status = document.getElementById('revealStatus');
      status.textContent = 'Forgiveness fizzing in progress‚Ä¶';
      let i = 0;
      const total = positions.length;
      function step(){
        if(i >= positions.length){
          status.textContent = 'Pixel Diet Coke generated! Enjoy the fizz ‚ú®';
          if(onComplete) onComplete();
          return;
        }
        const p = positions[i++];
        ctx.fillStyle = colors[p.v];
        ctx.fillRect(p.x*pixelSize, p.y*pixelSize, pixelSize, pixelSize);
        // small bubbling micro-animation: draw a tiny white speck occasionally
        if(Math.random() < 0.08){
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect(p.x*pixelSize + pixelSize/2 -1, p.y*pixelSize + 1, 2, 2);
        }
        // update status progress
        status.textContent = Forgiveness fizzing‚Ä¶ ${Math.round((i/total)*100)}%;
        setTimeout(step, 25 + Math.random()*45);
      }
      step();
    }

    // Expose functions
    window.__pixelArt = {
      drawFull,
      revealPixelByPixel,
      canvas
    };

    // Pre-draw for possible preloading
    drawFull();
  })();


  /* ---------- "I Forgive You" flow & matching game ---------- */
  (function(){
    const forgiveBtn = document.getElementById('forgiveBtn');
    const pixelBlock = document.getElementById('pixelBlock');
    const gameWrap = document.getElementById('gameWrap');
    const gameGrid = document.getElementById('gameGrid');
    const gameMsg = document.getElementById('gameMessage');

    let cardImageData = null; // will store dataURL of pixel art used on cards

    // Utility: create a small scaled version of the pixel canvas and return dataURL
    function generateCardImage(scale = 3){
      const src = window.__pixelArt.canvas;
      const w = src.width, h = src.height;
      // create temporary offscreen canvas
      const tmp = document.createElement('canvas');
      tmp.width = w * scale;
      tmp.height = h * scale;
      const ctx = tmp.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      // draw the pixel canvas scaled up with pixelated rendering
      ctx.drawImage(src, 0, 0, tmp.width, tmp.height);
      // return a rounded, cropped dataURL for card face
      return tmp.toDataURL('image/png');
    }

    // Build and start the matching game
    function startGame(){
      gameGrid.innerHTML = '';
      gameMsg.textContent = '';
      const baseImg = cardImageData || generateCardImage(2);
      cardImageData = baseImg;

      // prepare 4 pairs (8 cards)
      const pairs = 4;
      const deck = [];
      for(let i=0;i<pairs;i++){
        // we could vary a bit per card (hue shift) to make fun; but use same image for all pairs
        deck.push(baseImg);
        deck.push(baseImg);
      }
      // shuffle
      for(let i=deck.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }

      // game state
      let firstCard = null, secondCard = null, lock = false, matches = 0, moves = 0;

      deck.forEach((imgSrc, idx) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.setAttribute('data-idx', idx);
        card.innerHTML = `
          <div class="card-inner">
            <div class="face back">?</div>
            <div class="face front"><img src="${imgSrc}" alt="pixel can"></div>
          </div>`;
        gameGrid.appendChild(card);

        const inner = card.querySelector('.card-inner');

        card.addEventListener('click', ()=>{
          if(lock || card.classList.contains('matched') || card.classList.contains('flipped')) return;

          card.classList.add('flipped');
          if(!firstCard){
            firstCard = {card, idx, img:imgSrc};
            return;
          }
          secondCard = {card, idx, img:imgSrc};
          moves++;
          lock = true;

          // check match (they are same image src)
          if(firstCard.img === secondCard.img){
            // a match!
            firstCard.card.classList.add('matched');
            secondCard.card.classList.add('matched');
            matches++;
            // small celebration effect
            [firstCard.card, secondCard.card].forEach(c => c.classList.add('win'));
            setTimeout(()=> {
              [firstCard.card, secondCard.card].forEach(c => c.classList.remove('win'));
            }, 600);
            resetTurn();
            if(matches === pairs){
              gameWon();
            } else {
              lock = false;
            }
          } else {
            // not match ‚Äî flip back after short delay
            setTimeout(()=>{
              firstCard.card.classList.remove('flipped');
              secondCard.card.classList.remove('flipped');
              resetTurn();
              lock = false;
            }, 800);
          }
        });

      });

      function resetTurn(){ firstCard = null; secondCard = null; }
      function gameWon(){
        gameMsg.textContent = Our fizz is restored! ${moves} moves ‚Äî you're forgiven ü•§üíñ;
        // tiny confetti via emojis
        const conf = document.createElement('div');
        conf.innerHTML = '‚ú® üéâ ‚ú®';
        conf.style.fontSize = '1.4rem';
        conf.style.marginTop = '8px';
        gameMsg.appendChild(conf);
      }
    }

    // Forgive button flow
    forgiveBtn.addEventListener('click', async ()=>{
      forgiveBtn.disabled = true;
      forgiveBtn.textContent = 'Asking for forgiveness‚Ä¶ ‚ù§Ô∏è';
      // show pixel area
      pixelBlock.style.display = 'flex';
      // hide game for now
      gameWrap.style.display = 'none';

      // reveal pixel by pixel; when complete, draw full and generate card image
      window.__pixelArt.revealPixelByPixel(()=>{
        // ensure full draw
        window.__pixelArt.drawFull();
        // small pause, then show game
        setTimeout(()=> {
          // capture image for cards
          cardImageData = (function(){ return (function(){
            // use small scale for cards
            const tmp = document.createElement('canvas');
            const s = 2; // scale factor
            tmp.width = window.__pixelArt.canvas.width * s;
            tmp.height = window.__pixelArt.canvas.height * s;
            const ctx = tmp.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.drawImage(window.__pixelArt.canvas, 0, 0, tmp.width, tmp.height);
            return tmp.toDataURL('image/png');
          })(); })();

          // show game
          gameWrap.style.display = 'block';
          startGame();

          // final button text change
          forgiveBtn.textContent = 'You did it! ü•§';
        }, 800);
      });
    });

    // Accessibility: allow Enter/Space on button
    forgiveBtn.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' ') forgiveBtn.click();
    });

  })();
  </script>
</body>
</html>
